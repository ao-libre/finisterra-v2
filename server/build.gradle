import org.gradle.internal.os.OperatingSystem

plugins {
    id 'application'
    id 'artemis'
    id 'artemis-fluid'
}

mainClassName = 'Launcher'
eclipse.project.name = appName + '-server'

dependencies {
    api group: "net.onedaybeard.artemis", name: "artemis-odb", version: "$artemisVersion"
    api 'com.google.code.gson:gson:2.8.6'
    implementation "net.onedaybeard.artemis:artemis-fluid-core:2.4.0-SNAPSHOT"
    implementation project(':shared')
    api project(':server:components')
    api project(':shared:shared-components')
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.3.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.3.1'
}

test {
    useJUnitPlatform()
}

ext {
    fluidOutputDir = file("$buildDir/generated-sources/fluid/")
}

sourceSets {
    main.java.srcDirs = ['main', fluidOutputDir]
    test.java.srcDirs += ['test', 'main']
}

task printSourceSetInformation() {

    doLast {
        sourceSets.each { srcSet ->
            println "[" + srcSet.name + "]"
            print "-->Source directories: " + srcSet.allJava.srcDirs + "\n"
            print "-->Output directories: " + srcSet.output.classesDirs.files + "\n"
            print "-->Compile classpath:\n"
            srcSet.compileClasspath.files.each {
                print "  " + it.path + "\n"
            }
            println ""
        }
    }
}

fluid {
    generatedSourcesDirectory = fluidOutputDir
    classpath = sourceSets.main.compileClasspath
}
compileJava.dependsOn fluid

weave {
    classesDir = new File(buildDir, "classes/java/main")
    enableArtemisPlugin = true
    enablePooledWeaving = true
    generateLinkMutators = true
    optimizeEntitySystems = true
}
classes.finalizedBy(weave)
// Help intellIJ pick up the generated classes.
idea {
    module {
        generatedSourceDirs += fluidOutputDir
        excludeDirs -= file("$buildDir")
        excludeDirs -= file("$buildDir/src")
        excludeDirs += file("$buildDir/dependency-cache")
        excludeDirs += file("$buildDir/libs")
        excludeDirs += file("$buildDir/tmp")
    }
}

// Get current Operating System
def OS = OperatingSystem.current()

// Determine where the bundled application is going to be.
def releasePath = "${buildDir}/releases"

task dist(type: Jar) {
    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)

    manifest {
        attributes 'Main-Class': mainClassName
    }
    doLast {
        // We copy all the dependencies .JAR into the input folder for JPackage.
        copy {
            from configurations.compileClasspath
            from configurations.runtimeClasspath
            into "${buildDir}/libs"
        }
    }
}


// creates application bundle (executable + runtime)
task bundle(type: Exec, dependsOn: [dist, jlink]) {

    // Overwrite previous bundled application.
    if (file(releasePath).exists()) {
        delete(file(releasePath))
    } else {
        file(releasePath).mkdirs()
    }

    def commands = [
            JPackagePath,
            '--type', 'app-image',
            '--name', project.appName,
            '--vendor', "Argentum Online Libre",
            '--app-version', "1.15.0",
            '--dest', releasePath,
            '--runtime-image', prebuiltJRE,
            '--input', "${buildDir}/libs",
            '--main-class', project.mainClassName,
            '--main-jar', "${project.name}-${project.version}.jar"
    ]

    if (OS.isMacOsX()) {
        commands << "--java-options"
        commands << "-XstartOnFirstThread"
    }

    commandLine = commands

}

<<<<<<< HEAD
jar {
	archiveBaseName = "${appName}-server"
	dependsOn configurations.runtimeClasspath
	from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } } 
	manifest {
		attributes 'Main-Class': project.mainClassName
	}
=======
task packageDistribution(type: Zip, dependsOn: [bundle]) {
    archiveFileName = "finisterra-server-".concat((OS.isMacOsX() ? "MacOS" : OS.isLinux() ? "Linux" : "Windows")).concat(".zip")
    destinationDirectory = file("${project.buildDir}/releases/")

    from "${releasePath}/${project.appName}".concat(OS.isMacOsX() ? ".app" : "")
>>>>>>> feat: components as dependencies and track them using E instance
}